# Zapisanie sekwencji do pliku
sekwencje_fasta = """>Sequence_1
TACACTTGCGACAAACGGGTAGATTTTTTTCCGTACACGTGCTTAGATAAGTACCTTAGTGAA
>Sequence_2
TCTCCGCCTTCTGACCCTCATTTGCACGCGTATTCATAGACCAATTTCTAAACGCACGATCTAGGTCGCAAGACTGTGCTGCGTCATTTAGTGCCTTAAACATACGGCAATTGCCGGCCACGCGATTGGGAAGGACTAGA
>Sequence_3
CAGTCCATCTAAGGATTGGGCCTAAGCTGGGATCCTTAAACGTGACCGGTGCGGCGTAGTGTTATAAGCGCCCCTCGTATGGGGTGTTATTCGTGGCAGATTGGTTGTCAC
>Sequence_4
TACGTCTTGACTCCTTCTTCATGTAAAATGTTCTGACGGTAGTCAACGAACGTGACACCACCTGCAAGAAT
>Sequence_5
GGGTTCGAGATGATTTAAGGCTTGTGACTCGCAACCAGCTTATAGTAGCGGTCATACACACGCCACATGAGGACAAAGACGGCTGCACACGAGTTTACGATCATTTGGACAGTTTCCTGGTCCATTTTGTGCGCTCAACTTATAACCTCCTAGGCTGACGGTACCTGGCGAGGTGATTCTCTA
>Sequence_6
CCGACGTATGTTAAGGAGAAGCATCGCGCCTCATTAACCGTATCTCCTATACAGGAAGAACTACAACATTGGGACAGCGAAAGCAAGTCCTGCCCA
>Sequence_7
ACCTCAGGTGTGAGTCAGTTGCAAAAGCGATTGAAGCCATTGCCCGAACTTAGGCGCTCGTGATCAGAGAATCCACATCCCAGGATGTACACCCCAAACGTTATATCGCGATATAATTGGGAAGAATATCGTCGGGCGGCACGGCGGCCGCTTTTGGTCGCAATAGGTGCCAGATATTGCCATACAACCGA
>Sequence_8
CCCAGCTGAAATTCGTGTCACACGTTCTCCTCCAGGGACACCGCCAGCCCCGCGGTTGAATCGCATGACCGACTTC
>Sequence_9
TCGGCACCTCCTCATGTATGGATGCTATTTTTTAACAGGTAGCTCAGTCGCGCGTCAAAATCTCATCACGAAGCAGCGCCCAGGAAGATACGTATAAGACCTTCAAGTGCTACTAGGGTTAGGTGAGAGCCACCATCCGATTTATATCTGACAGCTAGACGCGAAT
>Sequence_10
TTCATTCCCCATCCTCCGGCGACCGCAACTAAGTTCTGATTGCAACTGGATTCCGGACGAACTTCACTACTTTC
>Sequence_11
GGTTTTTTCGGGGTCCTGAAATCCCTCTTAGACTTGAATGGTCTGTCCGATGGACATACCCGACTCACAATGCACCATG
>Sequence_12
GGCTTAATTGAGTGTTTATTTTGCGAAGCAAAGAGAGAGTGGCTTAGTTCGCTACCTCCCCAAGCGGATGCCGGCTTTGTCCTAGCGGGTGTCCTCGGCGTAATGTCCTTGATTGGTATAGACTAGCGGTTCGACCATGAATTGGATGGGTCTCACTGGGGCGTATATAGGCGTATA
>Sequence_13
TACGTCTTGACTCCTTCTTCATGTAAAATGTTCTGACGGTAGTCAACGAACGTGACACCACCTGCAAGAAT
>Sequence_14
GCGCAGAGGTTAGTAACTTAATCTCTGCAGTGGCGCTTGTTCCGGGAGTTGAAATGATAAGACCACGAGTGCAGCTCAGAATACTTAATTCGGGGCTGCCACGAGCCGAGCCGGATCCTCGCAGTGAGAACACTAGTGTCGTCGTGCGATCCTTAGGAACGGCTGGGTAATGGGAACATT
>Sequence_15
GACAAAATGGGTGGTGCGCCGGGGCAGTCCATCCAGGGAACTGCATCTCCTAGTTGTTGTTACGCAAGTGCGGTCACAGGCGATCCTGCAAACCAACGGTTCCCCCCTCTATCGGACGACAATCTAAGAATCCACGAGATGCAGACTTATCCTCATACATGGCGGCACTAGTCGGGACGTTGCGACAAGTGATAGTACG
>Sequence_16
GTGGAAAGACTCCGGTCCTCCCCATTTAATAAAAATGATGCTGGTAAAAAGTGCGCCACCCGGTGGCACTAAGGAGTGCGCTTCACAAAACCTTTAGTGGTAATGAGCATAAGAGTCCGTCTTCTATCGGGGGCGATAATGTGCTCCATCTTTCTCCCTTCTTGGTCCGCTCCAGCAGCAGATGGGATGT
>Sequence_17
CGAGAGAGGACACAGAGAGGAAGGACCCAGAAGGAGCACATCCCTATGTAGCCTAGGGATTGTGATTTGTCACGGA
>Sequence_18
AAAAGGTAAACAAAGCAGGAAATTCTTCTGCTCTTTAAGTCCTCGCCAAGCGGGAAATTAAGCCGCACATTCAGTGACTGGATTT
>Sequence_19
GGTCCCAAAGCGCCTTAGATGGTTTCTGTGCTGGATGGCGCATTGTCGCGAATCATTCCCTTCGCTGGCTGACTCGCAATGATCGGGATTGTGCAGTTCTATTTATGTTCATAGATTGCGCGTGATGGCGCTGTAGTG
>Sequence_20
CCTTAAACATTTCTGTAGTAAGTCCTCGTGCCGTTATCACATGCCTCTATGACCGGGCTACTCCAGCCACCCTCTTTATTAGCAGCTCTAGACTTCTCCCAGTCCAATAACGACATGTCCTGGAACG
>Sequence_21
GACGACTAGGCAACACTTGTCGCTGTACTACCCTAGGTTTTTTCAACCTAGTAAGATGGAGCGTCAAATTGGTCACTAGGGGTCGGAGGTGC
>Sequence_22
AAATTAGCAGTCTTAGTCTCATCGCAGTGTGGAGACGGGCTTTGTGTGACCGTGAAAGGTCATTGGTGGCGAAAACGGACCTGCT
>Sequence_23
CTCTAGATAGGGCCATTGCGCCTTAATGGGCGTCAAATCTCATTTTATATCGGCGATAGCTCAACTTCGTCGTAGAGTGGCGTTATCAAAATGATGGCTCGTATACTTAGTATGGGTCTAGTTAGGCGGCAGACTAGTGATCAGGCTCC
>Sequence_24
TAAAGGTGCTATGAGCAGAGGGTGTGAGATCCCGGGTCACATTTATGAAGTCCGGTGTGGTACAGGTGCTAGCAAGGGACAGATACTGTTCTGCCGGAGTCGGCACGGAGACCCACCGTCTTAATCCTACAAAGAGTCGAACATCTGAG
>Sequence_25
GTCCAACGATCTTTACCCATGCCTCTTAGGCCTTTAATAGCCCCCACAGCAGCCCGATTTTTCTCTCGGTCTGTGGAAAGGGTTGCCGGTGTAGGCGATGTCGCAACTGATTCAGGCGTAGCGATCCCCATGATCCTGCGTTCGACCATAGACCTGAACCAGGGTTAGGGAAGAAAGACAAC
>Sequence_26
TCATAAGCTTTGCATGAGGGGATGCAAAAAATTTTTGAGTGAAACTCAACGGTTCGGATCCGTCTACAGCGGTTCCTGTATTTGGCTATATAGTGAATAATGTACTTAGACCCGTGCGCTGATCTCAGAAATATACAGCGCCTCACGTGTGTGCAATACAGCCTACTCAAAACGACGAGTGG
>Sequence_27
GGAATTCTCCCGATGATTGGGCGACCCATTTCAACACGGCCAGACCAAAACTGCCATACCGCGGCGGATCTATGCGGATTTCGGAC
>Sequence_28
TATCACCACGGCCACTCCACGAGGCTTTTACTTACAGCTATTACGATTGGCAAAAATCGTTGGGACTGGGTAAACAAATCGGGACGGTGAATACCATCTCTCTAACACGTGGGAGTAGAGTGAGCAATGATCGCGCGACAGATCGCAGGCGATCAGTCGACTTGTAGGGAATCCATCCGT
>Sequence_29
GATTTTACCGACGTAGGCCCAGTCACCGTGCCACCGCGCACTTCAATCATATCCCCATGGTAATATCTTAGACTGTAGGATTGGCTCTAAAAATCTTCGACATTCAGTAGCAGATATTCCACTCATATTAAAGGTCTTTCGAGGACGTGGAGCAACTTCATG
>Sequence_30
TGTGTCGCGTACCCGAGAGGAAAAGTTAATTGTCGAAGCGGGTTCTTGGTAGTAAGACGTCATCATCACAGAACTGTACTCAGAGGCGAGTATGTCTTTAT"""

with open("sekwencje.txt", "w") as file:
    file.write(sekwencje_fasta)
print("Sekwencje zapisane do pliku 'sekwencje.txt'.")

# odczytanie zawartosci pliku i kazda sekwencja umiesczona w oddzielnej zmiennej

try:
    with open("sekwencje.txt", "r") as file:
        sekwencje = file.readlines()
        sekwencje = [seq.strip() for seq in sekwencje]
except FileNotFoundError:
        print("Plik 'sekwencje.txt' nie zostal znaleziony")
        exit()

for i, linia in enumerate(sekwencje, start=1):
      globals()[f"linia_1{i}"] = linia

nazwy_sekwencji = [line.strip() for line in sekwencje if line.startswith(">")]
sekwencje_tylko_dna = [line.strip() for line in sekwencje if not line.startswith(">")]

# pobranie sekwencji od uzytkownika
uzytkownik_sekwencja = input("\nPodaj swoja sekwencje DNA: ").strip()

if len(uzytkownik_sekwencja) > 200:
        print("Twja sekwencja jest zbyt dluga")
elif not all(nukleotyd in "ACTG" for nukleotyd in uzytkownik_sekwencja):
        print("Twoja sekwencja zawiera niepoprawne znaki")
else:
    uzytkownik_nazwa = f">Sequence_{len(nazwy_sekwencji) + 1}"
    nazwy_sekwencji.append(uzytkownik_nazwa)
    sekwencje_tylko_dna.append(uzytkownik_sekwencja)

    with open("sekwencje.txt", "a") as file:
            file.write(f"{uzytkownik_nazwa}\n{uzytkownik_sekwencja}\n")
    print("Twoja sekwencja została zapisana do pliku 'sekwencje.txt'.")

# obliczanie zawartosci GC
def oblicz_gc(sekwencja):
    if len(sekwencja) == 0:
        return 0
    gc = sekwencja.count("G") + sekwencja.count("C")
    return (gc / len(sekwencja)) * 100

# parametry
print("\nParametry sekwencji:")
for nazwa, sekwencja in zip(nazwy_sekwencji, sekwencje_tylko_dna):
        dlugosc = len(sekwencja)
        gc_percent = oblicz_gc(sekwencja)
        print(f"{nazwa}: Długość: {dlugosc}, Zawartość GC: {gc_percent:.2f}%")

# slownik
slownik_sekwencji = {nazwa: sekwencja for nazwa, sekwencja in zip(nazwy_sekwencji, sekwencje_tylko_dna)}

print("Slownik sekwencji:")
for nazwa, sekwencja in slownik_sekwencji.items():
        print(f"{nazwa}: {sekwencja}")

# konwersja slownika na DataFRame
import pandas as pd

data =[]
for nazwa, sekwencja in slownik_sekwencji.items():
                                data.append({
                                "Nazwa": nazwa,
                                "Sekwencja": sekwencja,
                                "Długość": len(sekwencja),
                                "GC%": oblicz_gc(sekwencja)
                                })

df = pd.DataFrame(data)
print("DataFrame po konwersji ze slownika:")
print(df)
print(df.columns)

# usuwanie duplikatow
df = df.drop_duplicates(subset=["Nazwa", "Sekwencja"])

# usuwanie wadliwych sekwencji
df = df[df["Długość"] <=200]
def jest_poprawna(sekwencja):
        return all(nukleotyd in "ACGT" for nukleotyd in sekwencja)

df = df[df["Sekwencja"].apply(jest_poprawna)]

# zawartosc dataframe
print("Zawartosc DataFrame")
print(df)

# Histogram
import matplotlib.pyplot as plt

plt.figure(figsize=(8, 5))
plt.hist(df["Długość"], bins=10, color="blue")
plt.title("Histogram dlugosci sekwencji")
plt.xlabel("Długość sekwencji")
plt.ylabel("GC%")
plt.show()

# wykres slupkowy GC%
plt.figure(figsize=(8, 5))
plt.bar(df["Długość"], df["GC%"], color="green")
plt.title("Zawartosc GC% w sekwencjach")
plt.xlabel("Długość sekwencji")
plt.ylabel("GC%")
plt.xticks(rotation=45)
plt.show()

# Scatter plot
plt.figure(figsize=(8, 5))
plt.scatter(df["Długość"], df["GC%"], color="red", marker="o")
plt.title("Długość sekwencji vs. GC%")
plt.xlabel("Długość sekwencji")
plt.ylabel("GC%")
plt.grid(True)
plt.show() 

# obsluga bledow
def oblicz_gc(sekwencja):
    """Oblicza zawartosc GC w sekwencji DNA"""
    try:
        gc = sekwencja.count("G") + sekwencja.count("C")
        return (gc / len(sekwencja)) * 100
    except ZeroDivisionError:
        print("Sekwencja pusta.")
        return 0
    
def wczytaj_sekwencje_z_pliku(sekwencje_fasta):
    """Wczytuje sekwencje z pliku tekstowego w formacie FASTA"""
    try:
        with open(sekwencje_fasta, "r") as file:
            lines = file.readlines()
    except FileNotFoundError:
        print(f"Błąd: Plik nie został znaleziony")
        return None, None

opis_programu = """1 krokiem było utworzenie pliku sekwencje.txt i zapis sekwencji DNA w formacie FASTA. 
Tworzymy ciag znakow, ktory zawiera nazwy  i sewkencje DNA sekwencje_fasta

with open("sekwencje.txt", "w") as file:
    file.write(sekwencje_fasta)
print("Sekwencje zapisane do pliku 'sekwencje.txt'.")

Otwieramy plik sekwencje.txt w trybie zapisu ("w"). Jeśli plik istnieje, zostanie nadpisany
Ciag znakow w formacie fasta (sekwencje_fasta) zostaje zapisany do pliku sekwencje.txt

2 krokiem bylo odczytanie sekwencji z pliku oraz kazda sekwencje umiescic w oddzielnej zmiennej

try:
    with open("sekwencje.txt", "r") as file:
        sekwencje = file.readlines()
        sekwencje = [seq.strip() for seq in sekwencje]
except FileNotFoundError:
        print("Plik 'sekwencje.txt' nie zostal znaleziony")
        exit()

Uzywamy bloku try, dzieki temu bez problemu mozemy obslzyc sytuacje wyjatku gdzie [lik nie zostanie znaleziony "FileNotFoundError".
Otwieramy plik w trybie odczytu ("r") i wczytujemy wszystkie linie z pliku jako listę (readlines())
seq.strip iteruje przez liste sekwencji gdzie seq to kazdy element tej listy. Dla kazdego elementu seq wywolany jest strip() usuwa biale znaki takie jak spacje czy znaki nowej linii z kazdej linii 
za wyjatkiem jesli nie znajdzie pliku (except FileNotFoundError) wtedy wyswietla sie blad "Plik 'sekwenja.txt' nie zostal znaleziony".

for i, linia in enumerate(sekwencje, start=1):
      globals()[f"linia_1{i}"] = linia

Pozwala zapisac kazda sekwencje w oddzielnej zmiennej, jest to mozliwe dzieki funkcji Python enumerate(), ktora pozwala iterowac przez listę
i jednoczesnie uzyskac dostep do indeksu i wartosci elementu. enumerate(sekwencje, start=1) umozliwia iteracje przez wszystkie linie z numerem od 1
globals() przypisuje zmienne w kodzie, w tym przypadku tworzy zmienne o nazwach linia_1, linia_2 

3 krokiem bylo pobranie sekwencji od uzytkownika, dodanie do pliku 

uzytkownik_sekwencja = input("\nPodaj swoja sekwencje DNA: ").strip()

Prosze o podanie uzytkownika nowej swojej sekwencji DNA umieszczajac strip() co pozwala na usuniecie bialych znakow (np. spacje)

if len(uzytkownik_sekwencja) > 200:
        print("Twja sekwencja jest zbyt dluga")
elif not all(nukleotyd in "ACTG" for nukleotyd in uzytkownik_sekwencja):
        print("Twoja sekwencja zawiera niepoprawne znaki")
else:
    uzytkownik_nazwa = f">Sequence_{len(nazwy_sekwencji) + 1}"
    nazwy_sekwencji.append(uzytkownik_nazwa)
    sekwencje_tylko_dna.append(uzytkownik_sekwencja)

Sprawdzam czy sekwencja uzytkownika jest krotsza niz 200 nukleotydow oraz czy zawiera dozowlone ukleotydy tj (A, C, T, G)
Jezeli sekwencja bedzie dluzsza niz 200 nukleotydow zostanie podana informacja "Twoja sekwencja jest zbyt dluga" natomiast jesli
nukleotydy beda inne niz "ACTG" zostanie podana infromacja "Twoja sekwencja zawiera niepoprawne znaki"ArithmeticError

    with open("sekwencje.txt", "a") as file:
            file.write(f"{uzytkownik_nazwa}\n{uzytkownik_sekwencja}\n")
    print("Twoja sekwencja została zapisana do pliku 'sekwencje.txt'.")

Jesli dane sa poprawne tworzymy nazwe dla nowej sekwencji, dodajemy nazwe i sekwencje do odpowiednich list oraz dopisujemy dane do pliku. Otwieramy plik "sekwencje.txt" a trybie "a" czyli append, 
ktory pozwala nam dopisac cos na koncu pliku, bez usuwania tego co bylo wczesiej. File write dodaje dane do pliku.

4 krokiem bylo Obliczenie zawartosci GC

def oblicz_gc(sekwencja):
    if len(sekwencja) == 0:
        return 0
    gc = sekwencja.count("G") + sekwencja.count("C")
    return (gc / len(sekwencja)) * 100

Celem bylo uzycie funkcji aby obliczyc procentowa zawartosc G i C w sekwencji DNA 
Jeśli sekwencja jest pusta "if len(sekwencja) == 0" zwracamy 0, w inncyh przpadkach zliczamy wystapienia G i C za pomoca count()
Obliczamy procent GC jako (liczba G i C / dlugos sekwencji) * 100

5 krokiem jes wyswietalnie parametrow sekwencji oraz sekwencji podanej przez uzytkownika 

print("\nParametry sekwencji:")
for nazwa, sekwencja in zip(nazwy_sekwencji, sekwencje_tylko_dna):
        dlugosc = len(sekwencja)
        gc_percent = oblicz_gc(sekwencja)
        print(f"{nazwa}: Długość: {dlugosc}, Zawartość GC: {gc_percent:.2f}%")

Celem jest wyswietlenie dlugosci i zawartosci GC kazdej sekwencji 
W tym celu iteruje po parach nazwa i sekwencja (for nazwa, sekwencja in zip(nazwy_sekwencji, sekwencje_tylko_dna)), obliczam dlugosc len() i zawartosc GC oblicz_gc()

6 krok to Tworzenie slownika 

nazwy_sekwencji = [line.strip() for line in sekwencje if line.startswith(">")]
sekwencje_tylko_dna = [line.strip() for line in sekwencje if not line.startswith(">")]

Rozdzielam odddzielnie nazyw sekwencji i sekwencje tylko dna 

slownik_sekwencji = {nazwa: sekwencja for nazwa, sekwencja in zip(nazwy_sekwencji, sekwencje_tylko_dna)}

print("Slownik sekwencji:")
for nazwa, sekwencja in slownik_sekwencji.items():
        print(f"{nazwa}: {sekwencja}")

Celem jest przechowywanie sekwencji w formacie slownikowym dlatego tworze slownik gdzie kluczami sa nazyw sekwencji a wartosciami sekwencje DNA      

7 krok to Konwersja slownika na DataFrame

import pandas as pd

Importuje biblioteke pandas ktora jest narzedziem do pracy z tabelami danych DataFrame

data =[]
for nazwa, sekwencja in slownik_sekwencji.items():
        data.append({
            "Nazwa": nazwa,
            "Sekwencja": sekwencja,
            "Długość": len(sekwencja),
            "GC%": oblicz_gc(sekwencja)
        })

df = pd.DataFrame(data)
print("DataFrame po konwersji ze slownika:")
print(df)
print(df.columns)

data = [] 
Tworzy pusta liste, ktora przechowuje dane o kazdej sekwencji 

dalej iteruje przez pary klucz-wartosc w slownik sekwencji (for nazwa, sekwencja in slownik_sekwencji.items():

Kolejno tworze slownik zawierajacynazwe, sekwencje, dlugosc i gc% (data.append({
            "Nazwa": nazwa,
            "Sekwencja": sekwencja,
            "Długość": len(sekwencja),
            "GC%": oblicz_gc(sekwencja)
        })
Tworze obiekt DataFrame z listy data kazdy eleent listy (slownik) staje sie jednym wierszem, a klucze slownika staja sie nazwami kolumn


8 krok to usuwanie duplikatow i wadliwych sekwencji 

df = df.drop_duplicates(subset=["Nazwa", "Sekwencja"])

usuwa wiersze, ktore zawieraja takie same wartosci w kolumnach"nazwa" i "sewkencja""PROJEKT PYTHON OD NOWA.ipynb"
drop.duplicates() funkcja biblioteki pandas, ktora pozwala usunac powtarzajace sie wiersze z dataframe
subset oznacza ze spr duplikaty wylacznie z tych dwoch kolumn

df = df[df["Długość"] <=200]

zachowuje tylko wiersze ktorych wartosc w kolumnie "dlugosc" jest mniejsza lub rowna 200 
df[...] filtruje DataFrame zachowujac tylko wiersze dla ktorych warunek jest spelniony 

def jest_poprawna(sekwencja):
        return all(nukleotyd in "ACGT" for nukleotyd in sekwencja)

df = df[df["Sekwencja"].apply(jest_poprawna)]

dla kazdej wartosci w kolumnie "sekwencja" wywoluje funckje jest poprawna, spr czy kolumna ta zawiera tylko poprawne nukleotydy

9 Wizualizacja 
import matplotlib.pyplot as plt
Pobieram narzedzie do rysowania wykresow, a pl to skrot aby latwiej go bylo uzywac

plt.figure(figsize=(8, 5))
plt.hist(df["Długość"], bins=10, color="blue")
plt.title("Histogram dlugosci sekwencji")
plt.xlabel("Długość sekwencji")
plt.ylabel("GC%")
plt.show()
Program bedzie szeroki na 8 jednostek i wysoki na 5 jednostek, Tworzymy histogram gdzie kazdy przedzial bedzie mial 10 slupkow
, slupki beda koloru niebieskiego, Tytuł to "Histogram dlugosci sekwencji", Oś poziomia (x) bedzie pokazywala dlugosc sekwencji
a os pionowa (y) bedzie zawierala "GC%", na koniec mowimy pokaz mi moj wykres (plt.show())

# wykres slupkowy GC%
plt.figure(figsize=(8, 5))
plt.bar(df["Długość"], df["GC%"], color="green")
plt.title("Zawartosc GC% w sekwencjach")
plt.xlabel("Długość sekwencji")
plt.ylabel("GC%")
plt.xticks(rotation=45)
plt.show()
Program bedzie szeroki na 8 jednostek i wysoki na 5 jednostek, Tworzymy wykres slupkowy gdzie df[Długośc] to lista dlugosci sekwencji no. 50,100,150.
to bedzie sie znajdowac na osi poziomej (x) a na osi pionowej (y) bedzie "GC%", slupki beda koloru zielonego. Oś poziomą (X) podpisujemy "Długośc sekwencji"
natomiast oś pionową (y) podpisujemy "GC%", etykiety na osi obracamy o 45 stopni (plt.xticks(rotation=45))
Na koniec wyswietlamy wykres (plt.show())

# Scatter plot
plt.figure(figsize=(8, 5))
plt.scatter(df["Długość"], df["GC%"], color="red", marker="o")
plt.title("Długość sekwencji vs. GC%")
plt.xlabel("Długość sekwencji")
plt.ylabel("GC%")
plt.grid(True)
plt.show() 
Program bedzi szeroki na 8 jednostek i wysoki n 5 jednostek, Tworzymy wykres punktowy gdzie kazdy punkt to jedna sekwencja. Na osi poziomej (x) znajduja sie 
wartosci df["Długośc"] czyli lista dlugosci sekwencji, na osi pionowej (y) znajduja sie wartosci df["GC%"] to lista wartości GC%. Punkty będą koloru czerownego,
natomiast marker="o" oznacza ze ksztalt punktow to male okregi. Dodajemy tytul wykresu plt.title("Długośc sekwencji vs. GC%") i podpisujemy osie 
plt.xlabel(Długośc sekwencji") oraz pltylabel("GC%"). Na wykresie włączamy siatkę plt.grid(True) oraz pokazujemy ywkres plt.show().

10 obsluga bledow
def oblicz_gc(sekwencja):
    """Oblicza zawartosc GC w sekwencji DNA"""
    try:
        gc = sekwencja.count("G") + sekwencja.count("C")
        return (gc / len(sekwencja)) * 100
    except ZeroDivisionError:
        print("Sekwencja pusta.")
        return 0

Funkcja (def oblicz_gc) oblikcza ile procent sekwencji DNA sklada się z dwóch liter "G" "C". Uzywamy nastepnie bloku try, dzieki temu bez problemu mozemy obslzyc sytuacje
gdyby cos bylo nie tak np pusta sekwencja. "gc = sekwencja.count("G") + sekwencja.count("C")" liczy ile razy "G" i "c" wystepuja w tekscie, dodaje je i zamipusje wynik zmiennej gc.
Dodatkowo blok ten obsluguje blad, sprawdza czy wystapil blad dzielenia przez zero (ZeroDivisionError). Blad ten wystapi gdy sekwencja jest pusta (nie ma nukleotydow, dlugosc=0). 
W takim przypadku zwraca wynik 0 i wpisuje "Sewkencja jest pusta".
    
def wczytaj_sekwencje_z_pliku(sekwencje_fasta):
    """Wczytuje sekwencje z pliku tekstowego w formacie FASTA"""
    try:
        with open(sekwencje_fasta, "r") as file:
            lines = file.readlines()
    except FileNotFoundError:
        print(f"Błąd: Plik nie został znaleziony")
        return None, None

Funckaj (def wczytaj_sekwencje_z_pliku) wczytuje sekwencje DNA zapisane w pliku tekstowym w formacie FASTA, jesli plik nie istnieje wypisuje komunikat o bledzie i zwraca None.
Używamy bloku try ktory pozwala jesli wystapi jakis blad np plik nie istnieje moze zapobiec awarii. 
"with open(sekwencje_fasta, "r") as file:
            lines = file.readlines()" 
Otwiera plik o nazwie sekwencje_fasta w trybie do odczytu "r", jesli plik nie istnieje Python zgalasza blad FileNotFoundError.
file.readlines() wczytuje wszystkie linei z pliku i zapisuje je w liscie lines. Kazda linia z pliku staje sie elemenetem tej listy. 
 except FileNotFoundError:
        print(f"Błąd: Plik nie został znaleziony")
        return None, None
Jesli plik nie istnieje funckja wpisuje komunikat "Blad: Plik nie zostal znaleziony" i funcja zwraca None jako brakujace dane. 
"""
